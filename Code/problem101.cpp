#include <iostream>
#include <fstream>
#include <string>
#include <cmath>
#include <vector>
#include <random>
#include <chrono>
#include <set>
#include <queue>
#include "math_unsigned.cpp"
#include "math_signed.cpp"

math::Signed gcd(math::Signed num1, math::Signed num2)
{
    if(num1 < 0)
    {
        num1 = -num1;
    }
    if(num2 < 0)
    {
        num2 = -num2;
    }
    if(num1 == 0)
    {
        return num2;
    }
    if(num2 == 0)
    {
        return num1;
    }
    if(num1 > num2)
    {
        return gcd(num1-num2*(num1/num2), num2);
    }
    return gcd(num2-num1*(num2/num1), num1);
}

math::Unsigned big_gcd(math::Unsigned num1, math::Unsigned num2)
{
    if(num1 == 0)
    {
        return num2;
    }
    if(num2 == 0)
    {
        return num1;
    }
    if(num1 > num2)
    {
        return big_gcd(num1-num2*(num1/num2), num2);
    }
    return big_gcd(num2-num1*(num2/num1), num1);
}



//Add num/denom times row2 to row1
void addRow(math::Signed ***matrix, int n, 
int row1, int row2, math::Signed num, math::Signed denom)
{
    for(int j = 0; j < n; j++)
    {
        matrix[row1][j][0] = denom*matrix[row1][j][0]*matrix[row2][j][1]
                            + num*matrix[row2][j][0]*matrix[row1][j][1];
        matrix[row1][j][1] *= matrix[row2][j][1]*denom;

        math::Signed g = gcd(matrix[row1][j][0], matrix[row1][j][1]);
        matrix[row1][j][0] /= g;
        matrix[row1][j][1] /= g;
    }
}

//Scales row by num/denom
void scaleRow(math::Signed ***matrix, int n, int row,
math::Signed num, math::Signed denom)
{
    for(int j = 0; j < n; j++)
    {
        matrix[row][j][0] *= num;
        matrix[row][j][1] *= denom;

        math::Signed g = gcd(matrix[row][j][0], matrix[row][j][1]);
        matrix[row][j][0] /= g;
        matrix[row][j][1] /= g;
    }
}

void swapRows(math::Signed ***matrix, int row1, int row2)
{
    math::Signed **temp = matrix[row1];
    matrix[row1] = matrix[row2];
    matrix[row2] = temp;
}

math::Signed ***inverse (math::Signed ***matrix, int n)
{
    math::Signed ***augmented = new math::Signed**[n];
    for(int i = 0; i < n; i++)
    {
        augmented[i] = new math::Signed*[2*n];
        for(int j = 0; j < n; j++)
        {
            augmented[i][j] = new math::Signed[2];
            augmented[i][j+n] = new math::Signed[2];
            augmented[i][j][0] = matrix[i][j][0];
            augmented[i][j][1] = matrix[i][j][1];
            if(i == j)
            {
                augmented[i][j+n][0] = 1;
            }
            else
            {
                augmented[i][j+n][0] = 0;
            }
            augmented[i][j+n][1] = 1;
        }
    }

    //Begin solving
    for(int i = 0; i < n; i++)
    {
        if(augmented[i][i][0] == 0)
        {
            for(int r = i+1; r < n; r++)
            {
                if(augmented[r][i][0] != 0)
                {
                    swapRows(augmented, i, r);
                    break;
                }
            }
        }
        for(int r = 0; r < n; r++)
        {
            if(i == r)
            {
                scaleRow(augmented, 2*n, r, augmented[i][i][1],
                augmented[i][i][0]);
            }
            else
            {
                addRow(augmented, 2*n, r, i, 
                static_cast<math::Signed>(-1)*augmented[r][i][0]*augmented[i][i][1],
                augmented[r][i][1]*augmented[i][i][0]);
            }
        }
    }

    math::Signed ***ans = new math::Signed**[n];
    for(int i = 0; i < n; i++)
    {
        ans[i] = new math::Signed*[n];
        for(int j = 0; j < n; j++)
        {
            ans[i][j] = new math::Signed[2];
            ans[i][j][0] = augmented[i][j+n][0];
            ans[i][j][1] = augmented[i][j+n][1];
            delete[] augmented[i][j];
        }
        delete[] augmented[i];
    }
    delete[] augmented;
    return ans;
}


math::Signed f(int x)
{
    math::Signed ans = 0;
    math::Signed add = 1;
    for(int i = 0; i <= 10; i++)
    {
        ans += add;
        add *= -x;
    }
    return ans;
}

math::Signed exp(math::Signed base, math::Signed e)
{
    math::Signed ans = 1;
    for(math::Signed i = 0; i < e; i += 1)
    {
        ans *= base;
    }
    return ans;
}

math::Signed firstDifference(math::Signed *sequence, math::Signed *coefficients, int n)
{
    for(int i = 1; i <= 11; i++)
    {
        math::Signed temp1 = 0;
        for(int x = 0; x <= n; x++)
        {
            temp1 += exp(i, x)*coefficients[x];
        }
        if(temp1 != sequence[i-1])
        {
            return temp1;
        }
    }
    return 0;
}

int main ()
{
    //Given the sequenc generated by 1-n+n^2-n^3...+n^10
    //Try to fit the first k terms with a polynomial of degree k-1
    //
    //Then over all such k which are not perfect, find the sum
    //of the first incorrect terms

    //Actually created arbitrary sized signed numbers for this
    //Fit the data with the equations 
    //A + Bx + Cx^2 + ... = term x
    //Then you have matrix M * C = T
    //Where M is matrix with powers of x, C is coefficients,
    //and T is the terms of the sequence
    //Most of the code is a matrix inverse calculator 
    //for rational numbers
    //With the Gauss-Jordan algorithm, to compute
    //C = M^-1 T
    //Then with the best fit polynomial, just 
    //Find the first term which is wrong

    math::Signed *sequence = new math::Signed[11];
    for(int i = 0; i < 11; i++)
    {
        sequence[i] = f(i+1);
    }

    math::Signed total = 0;
    for(int i = 1; i <= 10; i++)
    {
        math::Signed ***matrix = new math::Signed**[i];
        for(int r = 0; r < i; r++)
        {
            matrix[r] = new math::Signed*[i];
            for(int c = 0; c < i; c++)
            {
                matrix[r][c] = new math::Signed[2];
                matrix[r][c][0] = exp(r+1,c);
                matrix[r][c][1] = 1;
            }
        }

        math::Signed ***inv = inverse(matrix, i);
        math::Signed *rhs = new math::Signed[i];
        for(int j = 0; j < i; j++)
        {
            rhs[j] = sequence[j];
        }

        math::Signed *coefficients = new math::Signed[i];
        for(int j = 0; j < i; j++)
        {
            math::Signed temp1 = 0;
            math::Signed temp2 = 1;
            for(int index = 0; index < i; index++)
            {
                temp1 = temp1*inv[j][index][1] +
                temp2*inv[j][index][0]*rhs[index];
                temp2 *= inv[j][index][1];

                math::Signed g = gcd(temp1, temp2);
                temp1 /= g;
                temp2 /= g;
            }
            coefficients[j] = temp1;
        }
        total += firstDifference(sequence, coefficients, i-1);
    }
    std::cout << total << '\n';
    return 0;
}